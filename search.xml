<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>网络基础（一）</title>
      <link href="/2019/04/29/%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80%EF%BC%88%E4%B8%80%EF%BC%89/"/>
      <url>/2019/04/29/%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80%EF%BC%88%E4%B8%80%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h3 id="网络基础（一）"><a href="#网络基础（一）" class="headerlink" title="网络基础（一）"></a>网络基础（一）</h3><h4 id="协议"><a href="#协议" class="headerlink" title="协议"></a>协议</h4><p>协议本质上是一种约定，让通信双方彼此遵守。</p><p>两台主机约定好协议就可以了吗？当然不行，主机的生产厂家、操作系统、网络硬件设备…都不一样，这时候约定了一个共同的标准，大家都来遵守，这就是网络协议。</p><h4 id="网络协议"><a href="#网络协议" class="headerlink" title="网络协议"></a>网络协议</h4><p>为什么要分层？</p><p>答：经过分层之后，每一层可以遵守不同的协议，而且任意一层的变化都不会影响上层或者下层。</p><h5 id="OSI七层模型"><a href="#OSI七层模型" class="headerlink" title="OSI七层模型"></a>OSI七层模型</h5><p>复杂不实用。</p><table><thead><tr><th>应用层</th><th style="text-align:center">针对特定应用的协议</th></tr></thead><tbody><tr><td>表示层</td><td style="text-align:center">设备固有数据格式和网络标准数据格式的转换。</td></tr><tr><td>会话层</td><td style="text-align:center">通信管理。负责建立和断开通信连接（数据流动的逻辑通路）。管理传输层以下的分层。</td></tr><tr><td>传输层</td><td style="text-align:center">管理两个节点之间的数据传输。负责可靠传输（确保数据被可靠地传送到目标地址）。</td></tr><tr><td>网络层</td><td style="text-align:center">地址管理与路由选择。</td></tr><tr><td>数据链路层</td><td style="text-align:center">互连设备之间传送和识别数据帧。</td></tr><tr><td>物理层</td><td style="text-align:center">以0、1代表电压的高低、灯光的闪灭。界定连接器和网线的规格。</td></tr></tbody></table><h5 id="TCP-IP五层（四层）模型"><a href="#TCP-IP五层（四层）模型" class="headerlink" title="TCP/IP五层（四层）模型"></a>TCP/IP五层（四层）模型</h5><p>TCP/IP是一组协议的代名词，它还包括许多协议，组成了TCP/IP协议簇.</p><table><thead><tr><th style="text-align:center">应用层</th><th style="text-align:center">负责应用程序间沟通，如简单电子邮件传输（SMTP）、文件传输协议（FTP）、网络远程访问协议（Telnet）等. 我们的网络编程主要就是针对应用层。</th></tr></thead><tbody><tr><td style="text-align:center">传输层</td><td style="text-align:center">负责两台主机之间的数据传输. 如传输控制协议 (TCP), 能够确保数据可靠的从源主机发送到目标主机。</td></tr><tr><td style="text-align:center">网络层</td><td style="text-align:center">负责地址管理和路由选择. 例如在IP协议中, 通过IP地址来标识一台主机, 并通过路由表的方式规划出两台主机之间的数据传输的线路(路由). 路由器工作在网络层。</td></tr><tr><td style="text-align:center">数据链路层</td><td style="text-align:center">负责设备之间的数据帧的传送和识别. 例如网卡设备的驱动、帧同步(就是说从网线上检测到什么信号算作新帧的开始)、冲突检测(如果检测到冲突就自动重发)、数据差错校验等工作. 有以太网、令牌环网, 无线LAN等标准. 交换机(Switch)工作在数据链路层。</td></tr><tr><td style="text-align:center">物理层</td><td style="text-align:center">负责光/电信号的传递方式. 比如现在以太网通用的网线(双绞 线)、早期以太网采用的的同轴电缆(现在主要用于有线电视)、光纤, 现在的wifi无线网使用电磁波等都属于物理层的概念。物理层的能力决定了最大传输速率、传输距离、抗干扰性等. 集线器(Hub)工作在物理层</td></tr></tbody></table><p>由于物理层我们考虑的比较少，因此很多时候也可以称为TCP/IP四层模型。</p><h4 id="网络传输基本流程"><a href="#网络传输基本流程" class="headerlink" title="网络传输基本流程"></a>网络传输基本流程</h4><p>网络协议分4层，但是下面的3层是由操作系统中的内核来实现，用来完成通信中的细节，我们的用户不用关心，只用使用系统调用接口来实现数据的收发。</p><p>TCP/IP通讯过程：</p><p>从上到下的过程叫做封装，从下到上的过程叫做解包，解包中必须分用。 </p><p>不同的协议层对数据包有不同的称谓,在传输层叫做段(segment),在网络层叫做数据报 (datagram),在链<br>路层叫做帧(frame).</p><p>应用层数据通过协议栈发到网络上时,每层协议都要加上一个数据首部(header),称为封装<br>(Encapsulation).<br>首部信息中包含了一些类似于首部有多长, 载荷(payload)有多长, 上层协议是什么等信息.<br>数据封装成帧后发到传输介质上,到达目的主机后每层协议再剥掉相应的首部, 根据首部中的 “上层协议<br>字段” 将数据交给对应的上层协议处理。</p><h4 id="认识IP地址"><a href="#认识IP地址" class="headerlink" title="认识IP地址"></a>认识IP地址</h4><p>IP地址有俩个版本，我们现在谈论的IP协议，没有特殊说明的，默认都是指IPv4。</p><p>IP地址是在IP协议中，用来标识网络中不同主机的地址。</p><p>对于IPv4来说，IP地址是一个4字节，32比特位的整数。</p><p>通常也使用“点分十进制”的字符串表示IP地址，例如192.168.0.1；用点分割的每一个数字表示一个字节，范围是0  - 255；</p><h4 id="认识MAC地址"><a href="#认识MAC地址" class="headerlink" title="认识MAC地址"></a>认识MAC地址</h4><p>MAC地址用来识别数据链路层中相连的节点；</p><p>长度为48个比特位，6个字节，一般用16进制数字加上冒号的形式来表示（例如：  08:00:27:03：fb：19）</p><p>在网卡出厂时就确定了，不能修改，MAC地址通常是唯一的（虚拟机中的MAC地址不是真实的MAC地址，可能会冲突，也有些网卡支持用户配置MAC地址）</p>]]></content>
      
      
      <categories>
          
          <category> 网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 概念 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>多态</title>
      <link href="/2019/04/25/%E5%A4%9A%E6%80%81/"/>
      <url>/2019/04/25/%E5%A4%9A%E6%80%81/</url>
      
        <content type="html"><![CDATA[<h3 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h3><h4 id="1-多态的概念"><a href="#1-多态的概念" class="headerlink" title="1.多态的概念"></a>1.多态的概念</h4><p>多态就是不同的对象完成某个动作，产生不同的状态。</p><p>也就是不同继承关系的类对象，去调用了同一函数，产生了不同行为，就是多态。</p><h4 id="2-多态的实现"><a href="#2-多态的实现" class="headerlink" title="2.多态的实现"></a>2.多态的实现</h4><p>在继承中构成多态的俩个条件：</p><p>调用函数的对象必须是指针或者引用；被调用的函数必须是虚函数，且完成了虚函数的重写。</p><p>虚函数：就是在类的成员函数的前面加上virtual。    只有成员函数才能做虚函数，全局函数、静态函数都不可以。</p><p>虚函数的重写：派生类中有一个跟基类完全相同（函数名、参数、返回值）的虚函数，称子类的虚函数重写了基类的虚函数，也叫做虚函数的覆盖。</p><p>虚函数的协变：虚函数重写有一个例外，重写的虚函数的返回值可以不同，但必须是基类指针和派生类指针或者基类引用和派生类引用。</p><p>析构函数的重写：基类的析构函数最好写成虚函数。</p><table><thead><tr><th>函数重载</th><th>俩个函数在同一作用域，函数名、参数相同。</th></tr></thead><tbody><tr><td>重写(覆盖)</td><td>俩个函数分别在基类和派生类的作用域，函数名、参数、返回值都必须相同（协变例外），俩个函数必须是虚函数。</td></tr><tr><td>隐藏（重定义）</td><td>俩个函数分别在基类和派生类的作用域，函数名相同，俩个基类和派生类的同名函数不构成重写就是隐藏。</td></tr></tbody></table><h4 id="3-抽象类"><a href="#3-抽象类" class="headerlink" title="3.抽象类"></a>3.抽象类</h4><p>在虚函数的后面写上=0，则这个函数为纯虚函数。包含纯虚函数的类叫做抽象类（接口类），抽象类不能实例化出对象，派生类继承后也不能实例化出对象，必须重写纯虚函数，这也体现出了接口继承。</p><h4 id="4-C-11-override、final"><a href="#4-C-11-override、final" class="headerlink" title="4.C++11  override、final"></a>4.C++11  override、final</h4><p>final：被final修饰的纯虚函数不能被派生类重写。</p><p>override：修饰派生类虚函数强制完成重写，如果没有重写就会编译报错。</p><p>建议：派生类的纯虚函数搭配上override上使用。</p><h4 id="5-多态的原理"><a href="#5-多态的原理" class="headerlink" title="5.多态的原理"></a>5.多态的原理</h4><p>// 这里常考一道笔试题：sizeof(Base)是多少？<br>class Base<br>{<br>public:<br>    virtual void Func1()<br>    {<br>        cout &lt;&lt; “Func1()” &lt;&lt; endl;<br>    }<br>private:<br>    int _b = 1;<br>};</p><p>b成员，还有一个_vfptr放在对象的前面，叫做虚函数表指针。一个虚函数的类中至少都有一个虚函数表指针，因为虚函数的地址要被放在虚函数表中，虚函数表也叫虚表</p><p>//派生类对象也有虚表指针，其虚表指针一部分存的也是继承下来的，另外一部分存的是自己的。如果派生类中有虚函数的重写，基类对象的虚表和派生类对象的虚表也是不一样的，重写是语法层的叫法，覆盖是原理层的叫法。<br>//虚函数表的本质是存一个虚函数指针的指针数组，这个数组最后放了一个nullptr。<br>//虚表存的是虚函数指针，虚函数和普通函数都时存在代码段的，而且，对象中存的是虚表指针，虚表也是存在代码段的。</p><p>满足多态以后的函数调用，是运行起来以后到对象中去找的。不满足多态的函数调用是编译时就确认好的。也就是说，多态是动态绑定。</p><p>静态绑定（前期绑定、早绑定）：在程序编译期间确定了程序的行为，也称为静态多态，例如：函数重载。</p><p>动态绑定（后期绑定、晚绑定）：在程序运行期间，根据具体拿到的类型确定程序的具体行为，调用具体的函数，也成为动态多态。</p><h4 id="6-单继承和多继承关系的虚函数表"><a href="#6-单继承和多继承关系的虚函数表" class="headerlink" title="6.单继承和多继承关系的虚函数表"></a>6.单继承和多继承关系的虚函数表</h4><p>多继承派生类的未重写的虚函数放在第一个继承基类部分的虚函数表中。</p>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 概念 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>进程概念</title>
      <link href="/2019/04/23/%E8%BF%9B%E7%A8%8B%E6%A6%82%E5%BF%B5/"/>
      <url>/2019/04/23/%E8%BF%9B%E7%A8%8B%E6%A6%82%E5%BF%B5/</url>
      
        <content type="html"><![CDATA[<p>ps：提供了进程的一次性的查看，它提供的查看结果并不是动态连续的。<br>    ps aux：显示所有的进程<br>    ps -l：将目前属于您自己这次登入的PID与相关信息列示出來(只与自己的bash有关)<br>grep：是一种强大的文本搜索工具，全面搜索正则表达式并把匹配的行打印出来<br>top：打开Linux下的任务管理器指令（对进程时间监控）            q退出</p><p>/proc：proc文件系统，在Linux中有额外的机制可以为内核和内核模块将信息发送给进程– /proc 文件系统。最初设计的目的是允许更方便的对进程信息进行访问</p><p>cwd：当前进程的工作目录</p><p>exe：当前进程对应的可执行文件的目录</p><pre><code>进程控制kill：向目标进程发信号                   kill -l：查寻可以给进程发的信号的指令        kill -9 PID：终止进程        kill -19 PID：暂停进程</code></pre><p>./test &amp;：把test这个程序放在后台执行</p><p>​    并发：在一个CPU下多个进程进行切换，在一个时间段内，多个任务都得到推进叫做并发。</p><p>​    并行：在多CPU体系下，在一个时刻下，多个进程都在运行的情况叫做并行。</p><p>​    IO密集型：（I/O bound）:任务大量进行对I/O设备（硬盘/内存）进行读写操作。</p><p>​    CPU密集型：（CPU bound）:任务大量要求CPU进行计算、逻辑判断等功能，对CPU占有率高。</p><p>计算机存储器：1.内部存储器（内存）：易失性存储介质，速度快</p><p>​                           2.外部存储器（主要是磁盘）</p><p>​                                                   1》硬盘：永久性存储介质</p><p>​                                                   2》软盘：</p><p>编译好的程序是在计算机硬盘上存在的一个二进制文件。</p><h5 id="冯·诺依曼体系结构"><a href="#冯·诺依曼体系结构" class="headerlink" title="冯·诺依曼体系结构"></a>冯·诺依曼体系结构</h5><p>CPU集成俩个硬件，运算器和控制器。</p><p>输入或者输出设备，统称为外设。</p><p>这里的存储器指的是内存。</p><p>在数据层面上，CPU只能对内存进行读写，不能访问外设。</p><p>处理速度：CPU&gt;&gt;内存&gt;&gt;外设</p><p>离CPU越近的存储介质速度越快，离CPU越远的存储介质速度越慢。</p><p>寄存器—-》缓存—-》内存—-》硬盘—-》网盘</p><p>所有设备只能直接和内存打交道。</p><p>为什么硬盘上的程序文件要被加载到内存去运行？</p><p>答：CPU不能直接和硬盘接触，只能去内存中读取数据。</p><h4 id="操作系统Operator-System-OS"><a href="#操作系统Operator-System-OS" class="headerlink" title="操作系统Operator System(OS)"></a>操作系统Operator System(OS)</h4><h6 id="任何计算机系统都包含一个基本的程序集合，称为操作系统。"><a href="#任何计算机系统都包含一个基本的程序集合，称为操作系统。" class="headerlink" title="任何计算机系统都包含一个基本的程序集合，称为操作系统。"></a>任何计算机系统都包含一个基本的程序集合，称为操作系统。</h6><p>操作系统搭建在一堆硬件上，对硬件进行调度管理协调，然后让硬件跑起来。</p><p>但是操作系统和硬件之间并不是直接管理的关系，中间还有一套驱动，驱动一般都是对应的厂商提供的。</p><p>1.内核（进程管理、内存管理、文件管理、驱动管理）</p><p>2.外壳（函数库、shell）</p><h6 id="设计OS目的"><a href="#设计OS目的" class="headerlink" title="设计OS目的"></a>设计OS目的</h6><p>与硬件交互，管理所有的软硬件资源；为用户程序提供一个良好的执行环境。</p><h6 id="系统调用和库函数"><a href="#系统调用和库函数" class="headerlink" title="系统调用和库函数"></a>系统调用和库函数</h6><p>操作系统会对外会表现为一个整体，但是会暴露自己的部分接口，让用户使用，这部分由操作系统提供的接口，叫做系统调用。</p><p>系统调用在使用上，对用户要求比较高，所以有的开发者对系统调用就行了封装，从而形成了第三方库。</p><h4 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h4><p>进程包含代码、数据、PCB、虚拟地址空间、页表</p><p>进程是程序的一个执行实例，正在执行的程序。担当分配系统资源（CPU时间，内存）的实体。</p><h6 id="描述进程PCB"><a href="#描述进程PCB" class="headerlink" title="描述进程PCB"></a>描述进程PCB</h6><p>进程信息被放在一个叫做进程控制块的数据结构中，可以理解为进程属性的集合，称为PCB，Linux下的PCB：task_struct。PCB包含了目标进程的所有信息。</p><p>task_struct是PCB的一种，是Linux内核的一种数据结构，它会被装载到RAM（内存）里并包含着进程的信息。</p><p>task_struct内容分类：</p><p>标识符PID：描述本进程的唯一标识符，用来区别其他进程。类似于学号</p><p>状态：任务状态，退出代码，退出信号</p><p>​          r状态    s状态</p><p>​          在系统中，r状态仅仅表明该进程允许被放在CPU里去运行</p><p>​          再搞一条链表，只放r状态的进程的PCB，按优先级排好，叫做调度队列</p><p>优先级：相对于其他进程的优先级。系统进程数目众多，而CPU资源只有少量甚至一个，所以进程之间是具有竞争属性的。为了高效完成任务，更合理竞争相关资源，便具有了优先级。</p><p>程序计数器： 保存了将要取出的下一条指令的内存地址。在指令取出之后，程序计数器就被更新以便指向后继的指令。</p><p>​        计算机怎么知道代码执行到哪一步呢？</p><pre><code>     CPU寄存器当中包括了一个重要的寄存器（PC指针：保存着当前正在执行指令的下一条指令的地址），也就是这里的程序计数器。所以CPU要读取指令时，找PC指针，拿着PC指针里面的地址去找，读取了指令后，这个PC指针默认地址向下移。</code></pre><p>​                时间片：任何一个进程只要在CPU上运行，超过一定的时间范围后，强制从CPU上剥离下来。</p><p>是一个进程占有CPU资源的基本单位。</p><p>​        在单CPU的体系环境下，任何一个时刻只有一个进程在运行，但是，在一个时间段内，可以看到多个进程在运行。事实上，由于一台计算机只有一个CPU，所以永远不可能真正地同时运行多个任务。这些进程看起来像同时运行的，实则是轮番穿插地运行，由于时间片通常很短很短，所以用户不会感觉到。</p><p>上下文数据：把一个进程运行时CPU上寄存器上的数据叫做上下文数据。进程1的上下文数据存放在PCB中。进程1/进程2/进程3：叫做进程间切换。进程间切换必须要保存/恢复硬件上下文数据。</p><p>内存指针：PCB里能找到目标进程的代码和数据。</p><p>I/O状态信息：包括显示的I/O请求，分配给进程的I/O设备和被进程使用的文件列表。</p><p>记账信息：包括处理器时间总和，使用的时钟数总和，时间限制，记账号等。</p><p>getpid()：获取进程PID的函数  头文件：sys/types.h     unistd.h</p><p>getppid()：获取父进程PID的函数               一个进程对应的父进程的PID号是唯一的。</p><p>​                                                                        父进程是bash命令行解释器</p><p>fork：通过系统调用创建进程（通过代码创建进程，从进程中创建进程）</p><p>​    fork创建出来的子进程PCB是以父进程为模板的，父子进程代码共享，但是数据是私有的。</p><p>​        fork调用之后，有俩个进程要执行return语句。执行后，有俩个返回值，给父进程返回子进程的PID，给子进程返回0。</p><p>​        进程运行时具有独立性，体现在PCB不同、数据不同、代码不同。一个进程崩溃了不会影响别的进程。进程之间不相关，父子进程之间照样不相关。即使父子进程之间代码共享，一旦程序跑起来成为进程之后，都不能修改代码，都是只读的。</p><p>​        fork之后通常要用if分流：返回值&lt;0，创建失败。返回值==0，子进程工作。返回值&gt;0，父进程工作。</p><h5 id="进程状态"><a href="#进程状态" class="headerlink" title="进程状态"></a>进程状态</h5><p>R：运行状态，并不意味着程序一定在运行中，它表明程序要么在运行中要么在运行队列里。</p><p>S：睡眠状态，意味着进程在等待事件完成，重点是这个进程可以被终止，可以被杀掉。</p><p>D：磁盘休眠状态（深度休眠状态），在这个状态的进程通常会等待IO的结束，不可以被中断，防止被杀掉。</p><p>Z：僵尸状态</p><p>T：停止状态</p><p>X：死亡状态</p><h6 id="僵尸进程："><a href="#僵尸进程：" class="headerlink" title="僵尸进程："></a>僵尸进程：</h6><p>当子进程退出但不会立即释放子进程的PCB，会保存一段时间，并且会一直在等待父进程读取退出码。这段时间进程是僵尸状态。</p><p>僵尸进程会以终止状态保持在进程表中。</p><p>僵尸进程危害：</p><p>父进程一直不读取，那么子进程一直处于僵尸状态。</p><p>用数据维护退出状态，也属于进程基本信息，所以也保存在task_struct中，僵尸状态一直不退出，PCB一直都要维护。</p><h6 id="孤儿进程"><a href="#孤儿进程" class="headerlink" title="孤儿进程"></a>孤儿进程</h6><p>父进程先退出，子进程就称为“孤儿进程”。</p><p>孤儿进程被1号init进程（约等于系统）领养，当然要有inti进程（系统）回收。</p><h5 id="进程优先级"><a href="#进程优先级" class="headerlink" title="进程优先级"></a>进程优先级</h5><p>UID：代表执行者的身份</p><p>PID：代表这个进程的标识符</p><p>PPID：代表这个进程的父进程的标识符</p><p>PRI：代表这个进程的优先级，值越小越早被执行</p><p>NI：代表这个进程的nice值，表示进程可被执行的优先级的修正数值</p><p>PRI(new)=PRI(old)+nice</p><p>nice -n -5 ./test：开始执行程序就指定nice值</p><p>renice -5 -p 5200：PID为5200的进程nice设为-5</p><p>top进入后按”r”—&gt;输入进程PID—&gt;输入nice值：更改已存在的nice</p><h5 id="环境变量"><a href="#环境变量" class="headerlink" title="环境变量"></a>环境变量</h5><p>操作系统中用来指定操作系统运行环境的一些参数。在链接的时候通常就是环境变量帮助编译器查找动态静态库。在系统当中，环境变量通常具有全局特性</p><p>PATH：用来搜索可执行程序的路径</p><p>​        bin目录下存放着可执行文件，比如bin下的ls，如果想把自己的可执行文件例如myproc放到bin目录下，可以是可以，但不推荐，容易造成系统默认命令污染。</p><p>​    可以把当前路径加到环境变量PATH中去，用冒号做分隔符。PATH=$PATH：要被可执行的路径</p><p>HOME：当前用户的主工作目录，root用户和普通用户的HOME是不一样的。</p><p>HISTSIZE：保存历史命令记录的条数。</p><p>SHELL：当前Shell，它的值通常是/bin/bash。</p><p>查看环境变量：echo $环境变量名</p><p>获取环境变量：</p><ol><li><p>environ：系统提供的一个二级指针，就是指向环境变量表的一个指针，环境变量表就是一个个指向环境变量的指针的数组（字符指针数组），这个数组最后一个元素是空，每个指针指向一个以‘\0’结尾的环境字符串，</p></li><li><p>getenv();  </p><pre><code>int main(int argc,char* argv[],char* env[]){    printf(&quot;%s\n&quot;,getenv(&quot;PATH&quot;));    printf(&quot;%s\n&quot;,getenv(&quot;SHELL&quot;));}</code></pre><p>获取PATH和SHELL环境变量的路径。</p><p>3.putenv();</p></li></ol><p>​    设置环境变量；</p><p>export MYENY=”10000000000000000”</p><p>环境变量可以由父进程传给子进程</p><h4 id="程序地址空间"><a href="#程序地址空间" class="headerlink" title="程序地址空间"></a>程序地址空间</h4><p>写时拷贝：指的是俩个任务可以同时自由读取内存，但任意一个任务试图对内存进行修改时，内存就会复制一份提供给修改方单独使用，以免影响到其他的任务使用。</p><p>内核只为新生成的子进程创建虚拟空间结构，它们复制于父进程的虚拟空间结构，但是不为这些段分配物理内存，它们共享父进程的物理空间，当父子进程中有更改相应的段的行为发生时，再为子进程相应的段分配物理空间。</p><p>系统调用：</p><p>fork：复制当前进程</p><p>exec：使用新的可执行映像覆盖当前可执行映像</p><p>clone：创建子进程并从指定位置开始执行</p><p>fork出来子进程后，父进程和子进程谁先运行？</p><p>答：用户不知道，是由系统决定的。</p><p>   I am child，pid：3275，g_val：300，&amp;g_val：0x80497c8</p><p>I am parent，pid：3274，g_val：100，&amp;g_val：0x80497c8</p><p>此时父子进程对应的地址相同，但这个地址绝不是真正地物理内存地址。并且对应的物理内存地址绝不相同。</p><p>我们在C/C++语言所看到的地址，全部都是虚拟地址！物理地址，用户一般看不到，由操作系统（OS）统一管理。</p><p>虚拟地址空间：</p><p>父子进程如何做到代码共享？</p><p>答：父进程通过页表访问物理内存地址上的代码，子进程也通过页表访问物理内存上的代码</p><p>虚拟地址空间的作用：</p><p>1.让每个进程拥有了相同、独立内存空间，相互之间不会干扰。</p><p>2.读写内存更安全。由于系统和MMU的限制，使得进程无法操作到其他进程的数据。</p><p>3.不连续的物理空间可以映射成连续的虚拟地址空间。</p><p>4.进程分配的内存空间只有在实际使用时，才会触发缺页异常来分配实际物理空间，从而最大程度减少了内存空间的浪费。</p><p>共享的本质：不同的进程取地址通过页表映射到相同的物理内存。</p><p>私有的本质：不同的进程取地址通过页表映射到不同的物理内存。</p><h5 id="内核进程调度队列："><a href="#内核进程调度队列：" class="headerlink" title="内核进程调度队列："></a>内核进程调度队列：</h5><p>linux内核2.6所采用的调度算法的时间复杂度是O（1）；</p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 进程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>进程控制</title>
      <link href="/2019/04/23/%E8%BF%9B%E7%A8%8B%E6%8E%A7%E5%88%B6/"/>
      <url>/2019/04/23/%E8%BF%9B%E7%A8%8B%E6%8E%A7%E5%88%B6/</url>
      
        <content type="html"><![CDATA[<h3 id="进程控制"><a href="#进程控制" class="headerlink" title="进程控制"></a>进程控制</h3><h4 id="进程创建"><a href="#进程创建" class="headerlink" title="进程创建"></a>进程创建</h4><p>fork函数：创建新进程，新进程为子进程，而原进程为父进程。</p><pre><code>#include&lt;unistd.h&gt;pid_t fork(void);返回值：子进程中返回0，父进程返回子进程id，出错返回-1</code></pre><p>fork之前父进程独立执行，fork之后，父子俩个执行流分别执行。注意，fork之后，是父进程先执行还是子进程先执行呢？其实这也不是确定的，先执行哪个取决于内核所使用的调度算法，谁先执行完全由调度器执行。有的操作系统最先开始执行的是子进程，有的是最先执行父进程，但是整体思想都是一样的，无论先执行谁，一般情况下，一个进程不会一口气执行到结束。</p><p>为什么只有一个变量id来接收俩个返回值？</p><p>因为看起来只有1个，但其实在返回的时候已经变为俩个。因为fork之后的代码已经在父子各自的逻辑空间中运行了，因为后续代码是共享的，所以当然可以看到同一个id变量，又因为父子进程的数据是相互独立的，所以同一个id最后映射到不同的物理内存。所以fork之后才能用if语句进行分流。fork之后if和else的逻辑是同时被执行的。</p><p>时间片轮转调度算法是一种最古老，最简单，最公平且使用最广的算法。每个进程被分配一个时间段，称作它的时间片，即该进程允许运行的时间。如果在时间片结束时进程还在运行，则CPU将被剥夺并分配给另一个进程。如果进程在时间片结束前阻塞或结束，则CPU当即进行切换。调度程序所要做的就是维护一张就绪进程列表，当进程用完它的时间片后，它被移到队列的末尾。</p><p>写时拷贝（写时复制）技术：内核只为新生成的子进程创建虚拟空间结构，它们来复制于父进程的虚拟究竟结构，但是不为这些段分配物理内存，它们共享父进程的物理空间，当父子进程中有更改相应段的行为发生时，再为子进程相应的段分配物理空间。</p><p>fork()的实际开销就是复制父进程的页表以及给子进程创建惟一的进程描述符。</p><p>vfork：也是用来创建子进程的，但是子进程先运行</p><p>​         vfork用来创建一个子进程，而子进程和父进程共享地址空间，父子进程除了PCB不同，剩下的所有都相同。而fork出来的子进程具有独立地址空间。</p><p>​         vfork保证子进程先运行，在子进程调用exec或exit之后父进程才可能被调度运行。vfork的做法更加简单粗暴，内核连子进程的虚拟地址空间也不创建了，直接共享了父进程的虚拟空间，当然了，这种做法就顺水推舟的共享了父进程的物理空间。</p><h4 id="进程终止"><a href="#进程终止" class="headerlink" title="进程终止"></a>进程终止</h4><p>echo $?：最近一次进程的退出码</p><p>进程退出场景：代码运行完毕，结果正确；代码运行完毕，结果不正确；代码异常终止；</p><p>退出方法：</p><p>1）正常退出：return、exit、_exit</p><pre><code>exit:#include&lt;unistd.h&gt;void exit(int status);参数status定义了进程的终止状态。exit(0)表示正常退出当前进程，exit(1)表示非正常退出当前进程。父进程通过wait来获取该值。过程：1.执行用户通过atexit或on_exit定义的清理函数。2.关闭所有打开的流，所有的缓存数据均被写入。3.调用_exit函数。</code></pre><pre><code>_exit:#include&lt;unistd.h&gt;void _exit(int status);过程：直接使进程停止运行，关闭进程所有的文件描述符，清除其使用的内存空间，并销毁其在内核中的各种数据结构，但不会刷新流（stdin 、stdout、stderr……）。</code></pre><p>2）异常退出：ctrl + c，信号终止。</p><h4 id="进程等待"><a href="#进程等待" class="headerlink" title="进程等待"></a>进程等待</h4><p>输出型参数：输出型参数就是让函数把函数内部把数据输出到函数的外部的。</p><p>阻塞式：子进程还没有退出，父进程一直等待，不能去回收子进程，在这个期间，父进程没有被调度。只要把父进程挂起（进程状态设为非R状态）就可以了</p><p>非阻塞式：子进程还没有退出，父进程直接返回。</p><p>（基于非阻塞）轮询：周期性的检测子进程。（循环的非阻塞式等待）</p><p>阻塞式IO：</p><p>IO即input/output，阻塞式IO指的是“一旦输入/输出工作没有完成，则程序阻塞，直到输入/输出工作完成”。在目前，我们从书本上学到的语法用的基本都是阻塞式IO。比如c语言的stdio.h库的所有函数（包含scanf(),getchar(),gets()等函数）。最简单的例子：c语言的scanf()函数——当你scanf()要求输入两个数字时，你只输入一个数字，它也不会让你继续执行接下来的代码的。</p><p>非阻塞式IO：</p><p>非阻塞式IO其实也并非完全非阻塞，通常都是通过设置超时来读取数据的。未超时之前，程序阻塞在读写函数上；超时后，结束本次读取，将已读到的数据返回。通过不断循环读取，就能够读到完整数据了。如果多次连续超时读到空数据的话，则可以断开。C语言的Socket可以使用setsockopt()来设置recv()超时（通常也就Socket需要考虑超时）。</p><h5 id="进程等待的必要性："><a href="#进程等待的必要性：" class="headerlink" title="进程等待的必要性："></a>进程等待的必要性：</h5><p>子进程退出，父进程如果不管，就可能造成“僵尸进程”，僵尸进程不回收会造成内存泄漏。</p><p>僵尸进程杀不死只能通过wait的方式来等待回收。</p><p>子进程运行完退出，父进程通过进程等待，回收子进程资源（避免内存泄漏），获取子进程退出信息。</p><p>当父进程一旦等子进程，子进程没有就绪时，只要把父进程挂起就可以了，挂起就是把进程状态设置成非R状态就可以了。进程阻塞问题可以类比于理发店顾客排队等待理发问题。</p><p>许多进程在等待，实际上是许多进程的PCB在等待，只要把进程们的PCB用链表连起来，以队列的方式组织好，将来要唤醒哪个就从队列中操作。</p><p>可以更改进程状态来决定进程运行还是不运行。</p><p>进程如果异常退出一般都是由于受到了信号的干扰。</p><p>一个进程运行期间，没有受到一个信号：说明至少跑完了。</p><p>一个进程运行期间，没有受到一个信号，而且退出码为0：代码正常跑完，结果正确。</p><p>一个进程运行期间，没有受到一个信号，而且退出码为非0：代码正常跑完，结果不正确。</p><p>一个进程退出了，收到了一个9号信号，且退出码为1：进程代码都没跑完，结果不具备参考价值。</p><pre><code>wait()函数：#include&lt;sys/types.h&gt;#include&lt;sys/wait.h&gt;pid_t wait(int* status);返回值：成功返回被等待进程pid，失败返回-1参数：输出型参数，获取子进程退出状态，不关心可以设置成为NULL</code></pre><pre><code>waitpid()函数:pid_t waitpid(pid_t pid, int* status, int options);返回值：    当正常返回的时候waitpid返回收集到的子进程的进程PID；    如果设置了选项WNOHANG，而调用中waitpid发现没有已退出的子进程可收集，则返回0；    如果调用中出错，则返回-1，这时errno会被设置成相应的值以指示错误所在。参数：    pid:        pid=-1，等待任意一个子进程。与wait等效。        pid&gt;0，等待其进程ID与pid相等的子进程。    status:        status包含的信息包含2部分：退出码、是否收到信号        WIFEXITED(status):若为正常终止子进程返回的状态，则为真。（查看进程是否是正常退出）        WEXITSTATUS（status）：若WIFEXITED非零，提取子进程退出码（查看进程的退出码）    options：        WNOHANG：若pid指定的子进程没有结束，则waitpid（）函数返回0，不予以等待。若正常结束，则返回该子进程的ID。（非阻塞） </code></pre><p>wait和waitpid，都有一个status参数，该参数是一个输出型参数，由操作系统填充。如果传递NULL，表示不关心进程的退出状态信息，否则操作系统会根据该参数，将子进程的退出信息反馈给父进程。status不能简单的当做整形来看待，可以当作位图来看待。</p><p>​                    15                           8 7                          0 </p><p>正常终止：   退出状态               |                    0</p><p>被信号所杀：未用            core dump       终止信号</p><p>高8位表示子进程退出的退出码</p><p>低8位表示该进程有没有信号</p><p>退出码： 0xFF &amp; (status &gt;&gt; 8)</p><p>退出信号：status &amp; 0x7F</p><p>位操作移植性太差：系统给出了俩个宏</p><p>进程等待的作用：</p><p>1.回收子进程的僵尸状态</p><p>2.获得子进程的退出码</p><h4 id="进程程序替换"><a href="#进程程序替换" class="headerlink" title="进程程序替换"></a>进程程序替换</h4><p>如何让已经跑起来的程序去执行另一个新的程序</p><h5 id="替换函数"><a href="#替换函数" class="headerlink" title="替换函数"></a>替换函数</h5><pre><code>#include&lt;unistd.h&gt;int execl(const char *path, const char *arg, ...);int execlp(const char *file, const char *arg, ...);int execle(const char *path, const char *arg, ... ,char *const envp[]);int execv(const char *path, char *const argv[]);int execvp(const char *file, char *const argv[]);int execve(const char *path, char *const argv[], char *const envp[]);</code></pre><p>这些函数如果调用成功则加载新的程序，从启动代码开始执行，不再返回。如果调用出错返回-1。所以exec函数只有出错的返回值，没有成功的返回值。</p><p>l(list)：参数采用列表。  v(vector)：参数采用数组。</p><p>p(path)：有p自动搜索环境变量PATH。   e(env)：表示自己维护环境变量。</p><p>事实上，只有execve是真正的系统调用，其他5个函数最终都调用了execve。所以execve在man手册第2节，其他函数在man手册第3节。</p><p>程序替换的必要性：不想让子进程运行父进程的代码，想运行别的新的程序。</p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 进程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux环境基础开发工具</title>
      <link href="/2019/04/23/Linux%E7%8E%AF%E5%A2%83%E5%9F%BA%E7%A1%80%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/"/>
      <url>/2019/04/23/Linux%E7%8E%AF%E5%A2%83%E5%9F%BA%E7%A1%80%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/</url>
      
        <content type="html"><![CDATA[<h4 id="vim：编辑器"><a href="#vim：编辑器" class="headerlink" title="vim：编辑器"></a>vim：编辑器</h4><p>vim三种模式<br>命令模式（command mode）<br>插入模式（insert mode）<br>末行模式（last line mode）</p><p>vim正常模式命令集：</p><p>hjkl：左下上右</p><p>yy：复制<br> 10yy:把光标所在行及其下面行共10行都复制<br> yy10:把光标所在行复制10次</p><p>dd：剪贴<br> 3dd：把光标所在行及其下面俩行都剪贴</p><p>p：粘贴<br>u：撤销上一步操作<br>ctrl + r:恢复撤销</p><p>shift + ~:切换大小写</p><p>x:删除光标右侧的字符<br>     nx：删除光标右侧指定个数的字符<br>X：删除光标左侧的字符<br>    nX:删除光标左侧指定个数的字符</p><p>w：按单词向后移动光标<br>b：按单词向前移动光标</p><p>r+替换的字符：把光标处的字符替换成想要替换的字符<br>   3r+替换的字符：依次同时替换3个字符<br>R：替换模式<br>从光标处的字符依次往后被替换</p><p>shift + :    :进入末行模式<br>/main   :从上到下查找main<br>（或者?main）:表示从下到上查找main<br>结果出来后再按n：匹配的关键字的下一个</p><p>在末行模式下，vs test1.c同时分屏操作当前文件和test1.c</p><p>ctrl + w + h:光标移动到左侧的文件<br>ctrl + w + l:光标移动到右侧的文件</p><h4 id="gcc-g-：编译器"><a href="#gcc-g-：编译器" class="headerlink" title="gcc/g++：编译器"></a>gcc/g++：编译器</h4><p>gcc进行程序翻译<br>1.程序的预处理      gcc -E test.c -o test.i<br>2.编译                     gcc -S test.i -o test.s<br>3.汇编                     gcc -c test.s -o test.o<br>4.链接                     gcc test.o -o test<br>  执行                     ./test</p><p>gcc test.c -o test</p><p>动态链接：动态链接就是，在生成可执行程序的时候，只是引用的未定义的符号作了标识，到加载到内存中的时候才进行符号重定位。基本思想是把程序按照模块拆分成各个相对独立部分，在程序运行时才将它们链接在一起形成一个完整的程序，而不是像静态链接一样把所有程序模块都链接成一个单独的可执行文件。 假设现在有两个程序program1.o和program2.o，这两者共用同一个库lib.o,假设首先运行程序program1，系统首先加载program1.o，当系统发现program1.o中用到了lib.o，即program1.o依赖于lib.o，那么系统接着加载lib.o，如果program1.o和lib.o还依赖于其他目标文件，则依次全部加载到内存中。当program2运行时，同样的加载program2.o，然后发现program2.o依赖于lib.o，但是此时lib.o已经存在于内存中，这个时候就不再进行重新加载，而是将内存中已经存在的lib.o映射到program2的虚拟地址空间中，从而进行链接（这个链接过程和静态链接类似）形成可执行程序。</p><p>动态链接的优缺点：节省空间，效率相对高，对库的依赖性特别强（比如库的版本更新）</p><p>静态链接和动态链接两者最大的区别就在于链接的时机不一样，静态链接是在形成可执行程序前，而动态链接的进行则是在程序执行时</p><p>静态链接：静态链接就是，在生成可执行程序的时候，把目标文件.o 和 静态库 .a ，使用 ld 链接器，链接生成一个可执行程序。这是在程序加载前就完成的动作。</p><p>静态链接的优缺点：独立性、可移植性特别强，浪费空间，程序大小相对大，效率相对低</p><p>gcc在进行程序编译时默认链接的方式是动态链接。<br>ldd：查看文件的链接属性<br>gcc test.c -o test_static -static：修改test.c文件的链接属性为静态链接。<br>在Linux下，静态库的后缀为“.a”，动态库的后缀为“.so”</p><h4 id="gdb：调试工具"><a href="#gdb：调试工具" class="headerlink" title="gdb：调试工具"></a>gdb：调试工具</h4><p>程序的发布方式有两种，debug模式和release模式。Linux gcc/g++编译出来的二进制程序，默认是release模式。要使用gdb调试，必须在源代码生成二进制程序的时候，加上-g。例gcc test.c -o test_debug -g。</p><p>gdb test.c：进入gdb的交互式命令行模式</p><p>quit：退出</p><p>list / l 行号：显示文件代码，接着上次的位置往下列，每次列10行<br>list / l 函数名：列出某个函数的源代码</p><p>b 行号 ：在某一行设置断点<br>info b ：查看断点<br>d n：删除序号为n的断点<br>disable 1：关闭序列号为1的断点<br>enable 1： 开启序列号为1的断点</p><p>c：从当前位置开始连续而非单步执行程序<br>r：运行程序<br>n：单条执行<br>s：进入函数调用内部</p><p>p 变量：打印变量值<br>p &amp;变量：打印变量的地址<br>until 行号：跳转到行号的有意义行<br>finish：执行到当前函数返回，然后停下来等待命令</p><p>display变量：常显示<br>undisplay n：取消序列号为n的常显示</p><p>set var i=40:修改循环变量i的值为40<br>bt：查看各级函数调用</p><h4 id="Makefile：自动化构建工程"><a href="#Makefile：自动化构建工程" class="headerlink" title="Makefile：自动化构建工程"></a>Makefile：自动化构建工程</h4><p>src：查看源代码</p><p>创建一个Makefile文件（依赖关系和依赖方法）</p><p>hello:hello.c                         //生成的可执行文件：依赖的源文件<br>    gcc -o hello hello.c              // makefile的依赖方法必须以TAB键开头</p><p>.PHONY:clean                          //.PHONY是定义伪目标，伪目标的特点是总是被执行<br>clean:<br>    rm -f hello</p><p>hello:hello.o<br>    gcc hello.o -o hello<br>hello.o:hello.s<br>    gcc -c hello.s -o hello.o<br>hello.s:hello.i<br>    gcc -S hello.i -o hello.s<br>hello.i:hello.c<br>    gcc -E hello.c -o hello.i</p><p>.PHNOY:clean<br>clean:<br>    rm -f hello.i hello.s hello.o hello</p><p>make</p><p>make clean</p><p>makefile根据文件的修改时间判定一个源文件是否被修改过，进而决定是否需要被重新编译。</p><p>.PHONY起的作用时告诉makefile不要看文件修改时间，直接编译。</p><p>makefile带来的好处就是“自动化编译”，写好之后，只需要一个make命令，整个工程就完全自动编译，极大地提高了软件开发的效率。</p><p>\n： 换行</p><p>\r：  回车</p><p>ls &gt; makefile     把ls的结果写到makefile里面去</p><p>C函数如printf函数在输出时默认shell将数据输出到标准输出，如显示器。</p><p>而printf输出时并不是把消息直接打到显示器上，而是先写至自己的输出缓冲区。</p><p>而该缓冲区按行刷新（遇到\n，就把包括\n在内之前的所有字符串全部显示出来）。</p><p>fflush:清除读写缓冲区</p><p>stdin：终端的标准输入</p><p>stdout：终端的标准输出</p><p>stderr：终端的标准错误输出</p><h6 id="Linux下第一个小程序：进度条"><a href="#Linux下第一个小程序：进度条" class="headerlink" title="Linux下第一个小程序：进度条"></a>Linux下第一个小程序：进度条</h6><p>#include&lt;stdio.h&gt;</p><p>#include&lt;unistd.h&gt;<br>int main()<br>{<br>    int i=0;<br>    char bar[102]={‘\0’};<br>    const  char* lable=”|/-\“;<br>    while(i &lt;= 100)<br>    {<br>        bar[i]=’#’;<br>        printf(“[%-100s][%d%%][%c]\r”,bar,i,lable[i%4]);<br>        fflush(stdout);<br>        i++;<br>        usleep(50000);<br>    }<br>    printf(“\n”);<br>    return 0;<br>}</p><p>linux下三种安装方式：源码/rpm/yum</p><h4 id="yum：软件安装"><a href="#yum：软件安装" class="headerlink" title="yum：软件安装"></a>yum：软件安装</h4><p>yum需要处于联网状态才能正常工作</p><p>x86_64表示64位系统的安装包，i686表示32位系统的安装包</p><p>el7表示的是centos7/redhat7      el6表示centos6/redhat6</p><p>sudo yum install gcc.x86_64  安装软件</p><p>sudo yum remove gcc.x86_64   卸载软件</p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 进程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>继承</title>
      <link href="/2019/04/21/%E7%BB%A7%E6%89%BF/"/>
      <url>/2019/04/21/%E7%BB%A7%E6%89%BF/</url>
      
        <content type="html"><![CDATA[<h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3><h4 id="1-继承的概念"><a href="#1-继承的概念" class="headerlink" title="1.继承的概念"></a>1.继承的概念</h4><p>继承是面向对象程序设计使代码可以复用的最重要的手段，它允许程序员在保持原有类特性的基础上进行扩展，产生新的类，称为派生类。</p><p>继承后父类的成员都变成子类的一部分。</p><p>继承基类成员访问方式的变化</p><table><thead><tr><th></th><th>public继承</th><th>protected继承</th><th>private继承</th></tr></thead><tbody><tr><td>基类的public成员</td><td>派生类的public成员</td><td>派生类的protected成员</td><td>派生类的private成员</td></tr><tr><td>基类的protected成员</td><td>派生类的protected成员</td><td>派生类的protected成员</td><td>派生类的private成员</td></tr><tr><td>基类的private成员</td><td>在派生类中不可见</td><td>在派生类中不可见</td><td>在派生类中不可见</td></tr></tbody></table><p>方式总结：基类的私有成员在派生类中都是不可见的。基类的公有和保护成员在派生类中的访问方式是Min（成员在基类的访问限定符，继承方式）</p><h4 id="2-基类和派生类对象赋值转换"><a href="#2-基类和派生类对象赋值转换" class="headerlink" title="2.基类和派生类对象赋值转换"></a>2.基类和派生类对象赋值转换</h4><p>派生类对象可以赋值给 基类的对象 / 基类的指针 / 基类的引用，称为切片、切割。</p><p>基类的指针可以通过强制类型转化赋值给派生类的指针。</p><pre><code>pp = &amp;sobj                   // 指针指向派生类对象Student* ps1 = (Student*)pp; // 这种情况转换时可以的。ps1-&gt;_No = 10;pp = &amp;pobj;                  // 指针指向基类对象Student* ps2 = (Student*)pp; //编译没问题，运行就会出错，存在越界访问的问题。ps2-&gt;_No = 10;</code></pre><h4 id="3-继承中的作用域"><a href="#3-继承中的作用域" class="headerlink" title="3.继承中的作用域"></a>3.继承中的作用域</h4><p>子类和父类中有同名成员，子类成员将屏蔽父类对同名成员的直接访问，这种情况叫做隐藏，也叫重定义。但是可以通过基类::基类成员这种方式显式访问。如果是成员函数隐藏，只需要成员函数名相同就构成隐藏。</p><p>不在同一作用域的成员函数不构成函数重载，所以只能是隐藏，成员函数名相同就隐藏。</p><h4 id="4-派生类的默认成员函数"><a href="#4-派生类的默认成员函数" class="headerlink" title="4.派生类的默认成员函数"></a>4.派生类的默认成员函数</h4><p>派生类的构造函数必须调用基类的构造函数初始化基类的那一部分成员。如果基类没有默认的构造函数，则必须在派生类构造函数的初始化列表阶段显示调用。</p><p>派生类的拷贝构造函数必须调用基类的拷贝构造完成基类的拷贝初始化。</p><p>派生类的operator=必须要调用基类的operator=完成基类的复制。</p><p>派生类对象初始化先调用基类构造再调派生类构造。</p><p>派生类对象析构清理先调用派生类析构再调基类的析构。</p><p>面试题：如何实现一个不能继承的类？</p><p>答：将基类的构造函数设置成私有的，派生类得不到基类的构造函数，无法继承；使用关键字final（C++11）。</p><h4 id="5-继承与友元"><a href="#5-继承与友元" class="headerlink" title="5.继承与友元"></a>5.继承与友元</h4><p>友元不能继承。</p><h4 id="6-继承与静态成员"><a href="#6-继承与静态成员" class="headerlink" title="6.继承与静态成员"></a>6.继承与静态成员</h4><p>基类定义了一个static静态成员，则整个继承体系里面只有一个这样的成员。无论派生出多少个子类，都只有一个static成员实例 。</p><h4 id="7-复杂的菱形继承-钻石继承与菱形虚拟继承"><a href="#7-复杂的菱形继承-钻石继承与菱形虚拟继承" class="headerlink" title="7.复杂的菱形继承/钻石继承与菱形虚拟继承"></a>7.复杂的菱形继承/钻石继承与菱形虚拟继承</h4><p>单继承：一个子类只有一个直接父类时，称单继承。</p><p>多继承：一个子类有俩个或以上直接父类时，称多继承。</p><p>菱形继承：菱形继承是多继承的一种特殊情况，但是有数据冗余和二义性。</p><pre><code>a._name = &quot;haote&quot;;              //二义性a.Student::_name = &quot;haote1&quot;;     a.Teacher::_name = &quot;haote2&quot;;    //显示指定父类可以解决二义性，但是无法解决数据冗余</code></pre><p>虚拟继承（解决菱形继承问题）：D对象中将A放到的了对象组成的最下面，这个A同时属于B和C，那么B和C如何去找到公共的A呢？这里是通过了B和C的两个指针，指向的一张表。这两个表叫虚基表，这两个指针叫虚基表指针。虚基表中存的偏移量。通过偏移量可以找到下面的A。</p><h4 id="8-继承和组合（目的：复用）"><a href="#8-继承和组合（目的：复用）" class="headerlink" title="8.继承和组合（目的：复用）"></a>8.继承和组合（目的：复用）</h4><p>C++缺陷：语法复杂。有多继承就会有菱形继承，有菱形继承就会有菱形虚拟继承，底层实现会很复杂，但是后面的语言比如Java就没有。</p><p>公有继承是is–a的关系，每个派生类对象都是一个基类对象。</p><p>组合是has–a的关系，假设B组合了A，每个B对象中都有一个A对象。</p><p>优先使用对象组合，而不是类继承。组合的耦合度低，代码维护性好。但是有些关系适合继承，另外多态也要使用继承。</p>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 概念 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>类的6个默认成员函数</title>
      <link href="/2019/04/16/%E7%B1%BB%E7%9A%846%E4%B8%AA%E9%BB%98%E8%AE%A4%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0/"/>
      <url>/2019/04/16/%E7%B1%BB%E7%9A%846%E4%B8%AA%E9%BB%98%E8%AE%A4%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<h3 id="类的6个默认成员函数："><a href="#类的6个默认成员函数：" class="headerlink" title="类的6个默认成员函数："></a>类的6个默认成员函数：</h3><h4 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a><strong>构造函数</strong></h4><pre><code>构造函数：主要完成初始化。是一个特殊的成员函数，名字和类名相同，创建类类型对象时由编译器自动调用，保证每个数据成员都有一个合适的初始值，并且在对象的生命周期内只调用一次。构造函数的主要任务并不是开辟空间创建对象，而是初始化对象。特征：1.函数名与类名相同2.无返回值3.对象实例化时编译器自动调用对应的构造函数4.构造函数可以重载5.如果类中没有显示定义构造函数，则C++编译器就会自动生成一个无参的默认构造函数，一旦用户显示定义编译器将不再生成。如果用户定义了含有参数的构造函数，却定义了没有参数的类对象，此时编译器不会再生成一个默认的构造函数，抛出没有合适的默认构造函数可用。无参的构造函数和全缺省的构造函数都称为默认构造函数，并且默认构造函数只能有一个。注意：无参构造函数、全缺省构造函数、我们没写编译器默认生成的构造函数，都可以认为是默认成员函数。1.基本类型（内置类型）：int/char...2.自定义类型：class/struct定义的类型...默认生成的构造函数，对1不做处理，对2调用无参默认构造函数</code></pre><h4 id="析构函数"><a href="#析构函数" class="headerlink" title="析构函数"></a>析构函数</h4><pre><code>析构函数:与构造函数功能相反，析构函数不是完成对象的销毁，局部变量（在栈上）销毁工作是由编译器完成的。而对象在销毁时会自动调用析构函数，完成类的一些资源清理工作（比如在堆上动态开辟的资源）。特性：1.析构函数名是在类名前加上字符~2.无参数无返回值3.一个类有且只有一个析构函数。若未显示定义，系统会自动生成默认的析构函数4.对象生命周期结束时，C++编译系统自动调用析构函数析构函数调用的时候，是按反着的顺序析构的。比如先构造了类对象d1,d2,d3。析构的时候先析构d3，再析构d2，最后析构d1。因为对象是在函数的栈帧上的，要符合后进先出。析构函数对内置类型（基本类型）不做什么事情，但是对自定义类型还是会调用自定义类型的析构函数。</code></pre><h4 id="拷贝构造函数"><a href="#拷贝构造函数" class="headerlink" title="拷贝构造函数"></a><strong>拷贝构造函数</strong></h4><pre><code>拷贝构造函数：只有单个形参，该形参是对本类类型对象的引用（一般常用const修饰，用来保护，不能发生改变），在用已存在的类类型对象创建新对象时由编译器自动调用。Date d1;Date d2 = d1;//这个也是拷贝构造函数特征：1.拷贝构造函数是构造函数的一个重载形式2.拷贝构造函数的参数只有一个且必须使用引用传参，使用传值方式会引发无穷递归调用3.若未显示定义，系统默认的拷贝构造函数。默认的拷贝构造函数对象按内存存储按字节序完成拷贝，这种拷贝叫浅拷贝，或者值拷贝面试题：拷贝构造为什么有时候不使用默认的拷贝构造函数？如果在顺序表中使用浅拷贝，析构函数有free指针，先拷贝构造一个类对象，在free的时候，会把这个指针指向的空间释放俩次，导致程序崩溃。应使用深拷贝。所以不是任何时候都使用浅拷贝，日期这种类就可以用浅拷贝。将编译器生成的默认拷贝构造函数以及赋值运算符重载称之为浅拷贝方式，即值的拷贝。因此如果一个类中涉及到资源管理，不能使用编译器生成的默认拷贝构造函数以及赋值运算符重载。</code></pre><h4 id="运算符重载"><a href="#运算符重载" class="headerlink" title="运算符重载"></a><strong>运算符重载</strong></h4><pre><code>运算符重载：返回值类型 operator操作符 （参数列表）              bool operator==(const Date&amp; d1,const Date&amp; d2)注意：1.不能通过连接其他符号来创建新的操作符：比如operator@2.重载操作符必须有一个类类型或者枚举类型的操作数3.用于内置类型的操作符，其含义不能改变，例如：内置的整型+ ，不能改变其含义4.作为类成员的重载函数，其形参看起来比操作数数目少1，成员函数的操作符有一个默认的形参this，限定为第一个形参5. .* :: sizeof ?: .注意以上5个运算符不能重载。     d2 =d1;是运算符的重载，把d1的值赋值给d2data d3 =d1;不是，调用的是拷贝构造函数，拷贝构造一个新对象d3为了防止自己给自己赋值：void operator =(const Date&amp; d){    if(this != &amp;d)    {          _year = d._year;        _month = d._month;        _day = d._day;    }}连续赋值：Date&amp; operator=(const Date&amp; d){    if(this != &amp;d)    {        _year = d._year;        _month = d._month;        _day = d._day;    }    return *this;}d3 = d2 = d1;   //d3 = (d2.operator=(&amp;d2,d1)) 赋值运算符主要有4点：1.参数类型2.返回值3.检测是否自己给自己赋值4.返回*this5.一个类如果没有显示定义赋值运算符重载，编译器也会生成一个，完成对象按字节序的值拷贝</code></pre><h5 id="const成员"><a href="#const成员" class="headerlink" title="const成员"></a>const成员</h5><p>这里说点题外话</p><p>1.用const 修饰函数的参数</p><pre><code>如果参数作输出用，不论是传引用传指针，都不能加const，否则该参数失去输出功能。const只能修饰输入参数。如果参数采用指针传递，加const可以防止意外修改指针，起到保护作用。如果输入参数采用值传递，由于函数将自动产生临时变量用于复制该参数，该输入参数本来就无需const保护，所以不加const修饰，不管这个参数是内置类型还是自定义类型。对于自定义类型的参数而言，函数体内将产生自定义类型的临时变量用于复制参数，而临时对象的构造、复制、析构过程都会消耗时间，为了提高效率，可以采用传引用，不需要产生临时变量，为了防止改变参数，所以此时加上const。是否将void Fun(int x)改写成void Fun(const int&amp; x)，完全没必要，因为内置类型的参数不存在构造、析构过程，复制很快，传值和传引用效率几乎相同。总结：对于非内部数据类型的输入参数，应该将“值传递”的方式改为“const 引用传递”，目的是提高效率。例如将voidFunc(A a) 改为void Func(const A &amp;a)。     对于内部数据类型的输入参数，不要将“值传递”的方式改为“const引用传递”。否则既达不到提高效率的目的，又降低了函数的可理解性。例如void Func(int x) 不应该改为voidFunc(const int &amp;x)。</code></pre><p>2.用const修饰函数的返回值</p><pre><code>如果给以“指针传递”方式的函数返回值加const修饰，那么函数返回值（即指针）的内容不能被修改，该返回值只能被赋给加const 修饰的同类型指针。例如函数const char *GetString(void);如下语句将出现编译错误：char *str = GetString();正确的用法是const char *str =GetString();如果函数返回值采用“值传递方式”，由于函数会把返回值复制到外部临时的存储单元中，加const修饰没有任何价值。例如不要把函数int GetInt(void) 写成const int GetInt(void)。同理不要把函数AGetA(void) 写成const A GetA(void)，其中A 为用户自定义的数据类型。如果返回值不是内部数据类型，将函数AGetA(void) 改写为const A &amp;GetA(void)的确能提高效率。但此时千万千万要小心，一定要搞清楚函数究竟是想返回一个对象的“拷贝”还是仅返回“别名”就可以了，否则程序会出错。函数返回值采用“引用传递”的场合并不多，这种方式一般只出现在类的赋值函数中，目的是为了实现链式表达。d1 = d2 = d3</code></pre><p>3.const修饰类的成员函数</p><pre><code>将const修饰的类成员函数称之为const成员函数，const修饰类成员函数，实际修饰该成员函数隐含的this指针，this指针指向的内存空间的值不能发生变化，表明在该成员函数中不能对类的任何成员进行修改。值得注意的是，如果类中存在指针类型的数据成员即便是const，函数只能保证不修改该指针的值，并不能保证不修改指针指向的对象，const对象的成员是不可修改的,然而const对象通过指针维护的对象却是可以修改的。const成员函数可以被对应的具有相同形参列表的非const成员函数重载const成员函数不可以修改对象的数据,不管对象是否具有const性质.它在编译时,以是否修改成员数据为依据,进行检查然而加上mutable修饰符的数据成员,对于任何情况下通过任何手段都可修改,自然此时的const成员函数是可以修改它的</code></pre><h5 id="面试题："><a href="#面试题：" class="headerlink" title="面试题："></a>面试题：</h5><pre><code>1.const对象可以调用非const成员函数吗？不可以2.非const对象可以调用const成员函数吗？可以的，非const对象可以访问任意的成员函数，包括const成员函数。3.const成员函数内可以调用其它的非const成员函数吗？不可以。4.非const成员函数内可以调用其它的const成员函数吗？可以。</code></pre><h4 id="取地址及const取地址操作符重载"><a href="#取地址及const取地址操作符重载" class="headerlink" title="取地址及const取地址操作符重载"></a>取地址及const取地址操作符重载</h4><p>这两个默认成员函数一般不用重新定义 ，编译器默认会生成。</p><pre><code>Date* operator&amp;(){    return this ;}const Date* operator&amp;()const{    return this ;}</code></pre><p>推荐一篇很不错的文章，对理解const有很大的帮助。</p><p>C++ const修饰成员函数：<a href="https://blog.csdn.net/zheng19880607/article/details/23883437" target="_blank" rel="noopener">https://blog.csdn.net/zheng19880607/article/details/23883437</a></p>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 概念 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>stelen、sizeof</title>
      <link href="/2019/04/13/stelen%E3%80%81sizeof/"/>
      <url>/2019/04/13/stelen%E3%80%81sizeof/</url>
      
        <content type="html"><![CDATA[<p>今天看C++的string类，然后模拟实现的时候，发现了这样的一道题，主要是区别sizeof和strlen。刚开始完，和答案一对，发现其实错了好多。</p><p>下面给大家区分区分</p><pre><code>    char a1[] = &quot;\0&quot;;    cout &lt;&lt; sizeof(a1) &lt;&lt; &quot; &quot;;    cout &lt;&lt; strlen(a1) &lt;&lt; &quot; &quot;;    char a2[] = &quot;\\0&quot;;    cout &lt;&lt; sizeof(a2) &lt;&lt; &quot; &quot;;    cout &lt;&lt; strlen(a2) &lt;&lt; &quot; &quot;;    char a3[] = &quot;0000&quot;;    cout &lt;&lt; sizeof(a3) &lt;&lt; &quot; &quot;;    cout &lt;&lt; strlen(a3) &lt;&lt; &quot; &quot;;    char a4[] = &quot;\0000&quot;;    cout &lt;&lt; sizeof(a4) &lt;&lt; &quot; &quot;;    cout &lt;&lt; strlen(a4) &lt;&lt; &quot; &quot;;    char a5[] = &quot;\0 000&quot;;    cout &lt;&lt; sizeof(a5) &lt;&lt; &quot; &quot;;    cout &lt;&lt; strlen(a5) &lt;&lt; &quot; &quot;;</code></pre><p>​    a1的sizeof是2，strlen是0；sizeof求的是变量或者对象、类型所占内存的大小。a1第一个字符是\0，字符串结尾还有一个字符’\0’。所以有俩个字符，sizeof是2。strlen求的是字符串的长度，但是碰到’\0’就结束了。所以strlen是0；</p><p>​    a2是\ \ 0，第一个斜杠0是防止\0发生转义，所以第一个字符是\ ，第二个字符是0；所以sizeof是3，strlen是2；</p><p>​    a3很简单，sizeof是5，strlen是4；</p><p>​    a4前面的\000是转义字符，代表的是’\0’，所以内存中存的是’\0’,’0’,’\0’，所以sizeof是3，strlen是0；</p><p>​    a5的字符在内存的存储是’\0’,’ ‘,’0’,’0’,’0’,’\0’。所以sizeof是6，strlen是0。</p>]]></content>
      
      
      <categories>
          
          <category> C </category>
          
      </categories>
      
      
        <tags>
            
            <tag> strlen </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>进程信号</title>
      <link href="/2019/04/12/%E8%BF%9B%E7%A8%8B%E4%BF%A1%E5%8F%B7/"/>
      <url>/2019/04/12/%E8%BF%9B%E7%A8%8B%E4%BF%A1%E5%8F%B7/</url>
      
        <content type="html"><![CDATA[<h3 id="信号"><a href="#信号" class="headerlink" title="信号"></a>信号</h3><h4 id="信号的基本概念"><a href="#信号的基本概念" class="headerlink" title="信号的基本概念"></a>信号的基本概念</h4><p>用户、内核、进程向目标进程通知某些事件发生的机制。</p><p>进程能够处理信号的前提条件是得能够认识信号。</p><p>进程收到信号之后，有可能并不会立即处理，而是在合适的时候。</p><p>信号的产生对进程而言是异步的。</p><p>处理信号的3种方法：执行默认动作、忽略信号、执行自定义动作。</p><p>信号如果无法立即处理，得将信号先记录下来。</p><p>只有操作系统才能修改目标进程里的位图信息，只有操作系统才能给进程发送信号，但是产生信号的途径很多。</p><p>操作系统如何判定访问的内存是非法的？</p><p>答：一旦映射不过去就是非法的，执行者MMU发现映射不过去，就把错误记录下来。操作系统发现这个进程有非法访问的情况，默认杀死进程，发送9号信号。进程处理信号，默认自动退出。</p><p>MMU（内存管理单元），是CPU中用来管理虚拟存储器、物理储存器的控制线路。同时也负责将虚拟地址映射为物理地址，以及提供硬件机制的内存访问授权，多用户多进程操作系统。</p><p>mmap：一种内存映射文件的方法，mmap操作提供了一种机制，让用户程序直接访问设备内存，这种机制，相比较在用户空间和内核空间互相拷贝数据，效率更高。在要求高性能的应用中比较常见。mmap映射内存必须是页面大小的整数倍，面向流的设备不能就行mmap，mmap的实现和硬件有关。</p><p>1-31号信号：普通信号     34-64号信号：实时信号</p><p>每个信号都有一个编号和一个宏定义名称，这些宏定义可以在signal.h中找到。</p><p>进程的PCB中有一张位图，来记录信号。比特位的位置代表信号编号，比特位的内容代表对应信号是否产生。发信号就是修改进程的PCB，只有操作系统才有权限去修改信号。</p><h4 id="信号的产生"><a href="#信号的产生" class="headerlink" title="信号的产生"></a>信号的产生</h4><h5 id="1-键盘产生"><a href="#1-键盘产生" class="headerlink" title="1.键盘产生"></a>1.键盘产生</h5><p>键盘产生的信号只能发送给前台信号。Shell可以同时运行一个前台进程和任意多个后台进程。</p><p>core dumped（核心转储）：是操作系统在进程收到某些信号而终止时，将此时进程地址空间的内容以及有关进程状态的其他信息写出到一个磁盘文件。这种信息往往用于调试。</p><p>Post-mortem Debug：进程异常终止通常是因为有Bug，比如非法内存访问导致段错误，事后可以用调试器检查core文件以查清错误原因，这叫做事后调试。</p><p>CTRL + C：产生SIGINT信号；（终止进程）</p><p>CTRL + \：产生SIGQUIT信号；（终止进程并且Core Dump）</p><p>CTRL + Z：产生SIGSTP信号；（使前台进程停止）</p><h5 id="2-硬件异常"><a href="#2-硬件异常" class="headerlink" title="2.硬件异常"></a>2.硬件异常</h5><p>除0操作，CPU的运算单元会产生异常，内核将这个异常解释为SIGFPE信号发送给进程。</p><p>当前进程访问了非法内存地址，MMU会产生异常，内核将这个异常解释为SIGSEGV信号发送给进程。</p><h5 id="3-调用kill命令给进程发送信号"><a href="#3-调用kill命令给进程发送信号" class="headerlink" title="3.调用kill命令给进程发送信号"></a>3.调用kill命令给进程发送信号</h5><p>kill命令是调用kill函数实现的。</p><p>signal(SIGINT,handler);         //调用singal函数，使得进程处理SIGINT信号的方式由默认方式改为自定义方式：即调用后面的函数指针指向的函数。</p><p>ctrl + c就是2号信号。</p><p>前台进程在运行过程中用户随时可能按下Ctrl-C而产⽣生一个信号,也就是说该进程的用户空间代码执行到任何地方都有可能收到SIGINT信号⽽而终止,所以信号相对于进程的控制流程来说是异步的。</p><p>echo $? ：代表上一个命令执行后的退出状态</p><p>ulimit -a：显示当前系统给用户设置的资源方面的限制，一个用户所能创建的资源是受控受限的。</p><p>ulimit -c 1024：最大的core文件的大小，将core文件从0块改到1024块</p><p>ulimit -n：查看进程可以打开的最大文件描述符的数量。</p><p>ulimit -u：用户最大可用的进程数</p><p>线上服务器一般不会把core dumped打开，要不自启动一次写一次core文件，一晚上硬盘就会被写满。</p><h5 id="4-调用系统函数向进程发信号"><a href="#4-调用系统函数向进程发信号" class="headerlink" title="4.调用系统函数向进程发信号"></a>4.调用系统函数向进程发信号</h5><pre><code>#include&lt;signal.h&gt;int kill(pid_t pid, int signo);int raise(int signo);这俩个函数都是成功返回0，错误返回-1。kill函数是给一个指定的进程发送信号，raise函数是给当前进程发送信号。</code></pre><pre><code>#include&lt;stdlib.h&gt;void abort(void);   abort函数使当前进程接收到SIGABRT信号而异常终止。就像exit函数一样，abort函数总是会成功的，所以没有返回值。</code></pre><h5 id="5-由软件条件产生信号"><a href="#5-由软件条件产生信号" class="headerlink" title="5.由软件条件产生信号"></a>5.由软件条件产生信号</h5><pre><code>#include&lt;unistd.h&gt;unsigned int alarm(unsigned int seconds);调用alarm函数可以设定一个闹钟，也就是告诉内核在seconds秒之后给当前进程发SIGALRM信号，该信号的默认处理动作是终止当前进程。函数返回值是0或者是以前设定的闹钟时间还余下的秒数。</code></pre><h4 id="阻塞信号"><a href="#阻塞信号" class="headerlink" title="阻塞信号"></a>阻塞信号</h4><h5 id="1-信号其他相关常见概念"><a href="#1-信号其他相关常见概念" class="headerlink" title="1.信号其他相关常见概念"></a>1.信号其他相关常见概念</h5><p>实际执行信号的处理动作称为信号递达（Delivery）。</p><p>信号从产生到递达之间的状态，称为信号未决（Pending）。</p><p>进程可以选择阻塞（Block）某个信号。</p><p>被阻塞的信号产生时将保持在未决状态，直到进程解除对此信号的阻塞，才执行递达的动作。</p><p>注意：阻塞和忽略是不同的，只要信号被阻塞就不会递达，而忽略是在递达之后可选的一种处理动作。</p><h5 id="2-在内核中的表示"><a href="#2-在内核中的表示" class="headerlink" title="2.在内核中的表示"></a>2.在内核中的表示</h5><p>对于每个信号，task_struct都有俩个标志位分别表示阻塞（block）和未决（pending），还有一个函数指针表示处理动作。信号产生时，内核在进程控制块中设置该信号的未决标志，直到信号递达才清除该标志。</p><p>如果在进程解除对某信号的阻塞之前这种信号产生过多次，将如何处理？允许系统递送该信号一次或多次。Linux是这样实现的：普通信号在递达之前产生多次只计一次，而实时信号在递达之前产生多次可以依次放一个队列里。</p><h5 id="3-sigset-t"><a href="#3-sigset-t" class="headerlink" title="3.sigset_t"></a>3.sigset_t</h5><p>未决和阻塞标志可以用相同的数据类型sigset_t来存储，sigset_t称为信号集，这个类型可以表示每个信号的是否被阻塞，是否处于未决状态。</p><p>阻塞信号集（信号屏蔽字）、未决信号集</p><h5 id="4-信号集操作函数"><a href="#4-信号集操作函数" class="headerlink" title="4.信号集操作函数"></a>4.信号集操作函数</h5><p>sigset_t类型对于每种信号用一个bit表示有效或者无效状态，至于这个类型内部如何存储这些bit则依赖于系统，我们是不知道的，使用者只能调用信号集操作函数来操作sigset_t变量，而不是对它的内部数据做任何解释，比如printf直接打印sigest_t是没有意义的。</p><pre><code>#include&lt;signal.h&gt;int sigemptyset(sigset_t *set);    //初始化set所指向的信号集，使其中所有信号的对应bit清零，表示该信号集不包含任何有效信号。int sigfillset(sigset_t *set);//初始化set所指向的信号集，使其中所有信号的对应bit置为1，表示该信号集的有效信号包括系统支持的所有信号。int sigaddset(sigset_t *set, int signo);int sigdelset(sigset_t *set, int signo);int sigismember(const sigset_t *set, int signo);前四个函数都是成功返回0，出错返回-1。sigismember是一个布尔函数，用于判断一个信号集的有效信号中是否包含某种信号，若包含则返回1，不包含返回0，出错返回-1。</code></pre><p>在使用sigest_t类型的变量之前，一定要调用sigemptyset或sigfillset做初始化，使信号集处于确定的状态。初始化sigset_t变量之后就可以再调用sigaddest和sigdelset在该信号集中添加或删除某种有效信号。</p><h5 id="5-sigprocmask"><a href="#5-sigprocmask" class="headerlink" title="5.sigprocmask"></a>5.sigprocmask</h5><pre><code>#include&lt;signal.h&gt;int sigprocmask(int how,const sigest_t *set, sigset_t *oset);返回值：成功返回0，出错返回-1。</code></pre><p>读取或更改进程的信号屏蔽字（阻塞信号集）。</p><p>如果set是非空指针，则更改进程的信号屏蔽字，参数how指示如何更改。如果oset是非空指针，则读取进程的当前信号屏蔽字通过oset参数传出。如果俩个都是oset都是非空指针，则先将原来的信号屏蔽字备份到oset里，然后根据set和how参数更改信号屏蔽字。假设当前的信号屏蔽字为mask，下标说明了how参数的可选值。</p><table><thead><tr><th>SIG_BLOCK</th><th>set包含了我们希望添加到当前信号屏蔽字的信号，相当于mask = mask \</th><th>set.</th></tr></thead><tbody><tr><td>SIG_UNBLOCK</td><td>set包含了我们希望从当前信号屏蔽字中解除阻塞的信号，相当于mask = mask &amp; ~set</td></tr><tr><td>SIG_SETMASK</td><td>设置当前信号屏蔽字为set所指向的值，相当于mask=set</td></tr></tbody></table><p>如果调用sigprocmask解除了对当前若干个未决信号的阻塞，则在sigprocmask返回前，至少将其中一个信号递达。</p><h5 id="6-sigpending"><a href="#6-sigpending" class="headerlink" title="6.sigpending"></a>6.sigpending</h5><pre><code>#include&lt;signal.h&gt;sigpending();读取当前进程的未决信号集，通过set参数传出。调用成功则返回0，出错则返回-1。</code></pre><h4 id="捕捉信号"><a href="#捕捉信号" class="headerlink" title="捕捉信号"></a>捕捉信号</h4><h5 id="1-内核如何实现信号的捕捉"><a href="#1-内核如何实现信号的捕捉" class="headerlink" title="1.内核如何实现信号的捕捉"></a>1.内核如何实现信号的捕捉</h5><p>如果信号的处理动作是用户自定义函数，在信号递达时就调用这个函数，这称为捕捉信号。</p><p>1）在执行某条指令时，因为中断、异常或者系统调用进入内核。（用户态）</p><p>2）内核处理完异常准备回用户模式之前，先处理当前进程中可以递送的信号。（内核态）</p><p>3）如果信号的处理动作是自定义的信号处理函数，则回到用户模式执行信号处理函数，而不是回到主控制流程。（内核态）</p><p>4）执行完信号处理函数，返回时执行特殊的系统调用再次进入内核。（用户态）</p><p>5）返回用户模式，从上次被中断的地方继续向下执行。（内核态）</p><p>信号的处理是进程从内核态切回到用户态时，开始进行处理。</p><p>系统调用或中断异常时，才会进入到内核态。内核态的权限要比用户态的权限大。</p><h5 id="2-sigaction"><a href="#2-sigaction" class="headerlink" title="2.sigaction"></a>2.sigaction</h5><pre><code>#include&lt;signal.h&gt;int sigaction(int signo, const struct sigaction *act, struct sigaction *oact)sigaction函数可以读取和修改指定信号相关联的处理动作。参数：    signo：指定信号的编号。    若act非空，根据act修改该信号的处理动作。    若oact非空，则通过oact传出该信号原来的处理动作。    act 和 ocat指向 sigaction结构体：struct sigaction{void *sa_handler,...,sigset_t sa_mask,...}    将sa_handler赋值为常数SIG_IGN传给sigaction表示忽略信号。                     常数SIG_DEL         表示执行系统默认动作；                     函数指针         表示用自定义函数捕捉信号。    如果调用信号处理函数时，除了当前信号被自动屏蔽，还希望屏蔽另外一些信号，使用sa_mask可以屏蔽多个信号。返回值：    调用成功返回0，出错返回-1。</code></pre><p>当某个信号的处理函数被调用时，内核自动将当前信号加入进程的信号屏蔽字，当信号处理函数返回时自动回复原来的信号屏蔽字。这样就保证了在处理某个信号时，如果这种信号再次产生，那么它会被阻塞到当前处理结束为止。</p><h5 id="3-pause"><a href="#3-pause" class="headerlink" title="3.pause"></a>3.pause</h5><pre><code>#include&lt;unistd.h&gt;int pause(void);pause函数使调用进程挂起直到有信号递达。如果信号的处理动作是终止，则进程终止，pause函数没有机会返回。如果信号的处理动作是忽略，则进程继续处于挂起状态，pause不返回。如果信号的处理动作是捕捉，则调用信号处理函数，pause返回-1，error设置为EINTR，错误码EINTR表示被信号中断。所以，pause只有出错的返回值。</code></pre><p>pause要返回的2个前提条件：</p><p>1.收到信号   2.该信号被捕捉</p><h4 id="可重入函数"><a href="#可重入函数" class="headerlink" title="可重入函数"></a>可重入函数</h4><p>一个函数被多个执行流重复进入的时候叫做可重入。</p><p>不可重入函数：被多个执行流重复进入，导致出错的函数。（一般使用static、全局变量、malloc（free）申请空间、调用标准IO库的函数）</p><p>可重入函数：即便被多个执行流重复进入也不会出错的函数。（一般是清一色的局部变量的函数）</p><h4 id="volatile：保持内存的可见性"><a href="#volatile：保持内存的可见性" class="headerlink" title="volatile：保持内存的可见性"></a>volatile：保持内存的可见性</h4><p>1）没有优化，没有加volatile。代码正常退出。</p><p>2）加了优化，没有加volatile。  优化：把flag变量放到寄存器里。内存里的变量发生了改变，而寄存器里的变量没有改变。</p><p>3）加了优化，加了volatile。</p><h4 id="竞态条件与sigsuspend函数"><a href="#竞态条件与sigsuspend函数" class="headerlink" title="竞态条件与sigsuspend函数"></a>竞态条件与sigsuspend函数</h4><p>时序问题是编程过程中最难发现解决的bug。</p><p>1.屏蔽SIGALRM信号 2.alarm(sec)3.解除SIGALRM信号的屏蔽 4.pause（）</p><p>从解除信号的屏蔽到pause之间存在间隙，信号仍有可能递达。</p><p>1.屏蔽SIGALRM信号 2.alarm(sec)3.pause（） 4.解除SIGALRM信号的屏蔽</p><p>这样更不行了，pause根本不可能等到SIGALRM信号，已经屏蔽了。</p><pre><code>sigsuspend：#include&lt;signal.h&gt;int sigsuspend(const sigset_t *sigmask);</code></pre><h4 id="SIGCHLD信号"><a href="#SIGCHLD信号" class="headerlink" title="SIGCHLD信号"></a>SIGCHLD信号</h4><p>父进程可以阻塞子进程结束，也可以非阻塞地查询是否有子进程等待清理（轮询）。采用第一种方式，父进程阻塞了就不能处理自己的工作；采用第二种，父进程在处理自己工作的同时还要记得时不时地轮询一下，程序实现复杂。</p><p>SIGCHLD信号的处理函数,这样父进程只需专心处理⾃自己的工作,不必关心子进程了,子进程 终止时会通知父进程，父进程在信号处理函数中调用wait清理子进程即可。</p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 进程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux常见指令1</title>
      <link href="/2019/04/10/Linux%E5%B8%B8%E8%A7%81%E6%8C%87%E4%BB%A41/"/>
      <url>/2019/04/10/Linux%E5%B8%B8%E8%A7%81%E6%8C%87%E4%BB%A41/</url>
      
        <content type="html"><![CDATA[<p>. 表示当前目录</p><p>.. 表示上级目录</p><p>/  单独使用表示根目录 ，路径当中使用表示分隔符</p><p>相对路径：cd ../day02/   相当于当前文件的路径。</p><p>绝对路径：cd /home/haote216/linux/   从/开始从上到下去检索文件的路径，绝对路径只有1条。</p><p>文件=属性+内容</p><p>属性{大小、创建时间、修改时间、属性修改时间、创建者、权限、格式、类型}</p><p>inode:索引节点，在linux中把文件的属性全放在一起，是文件属性（是数据）</p><p>文件的ACM时间代表的什么含义？<br>Access time:文件最后访问时间<br>Modify time:文件最后修改时间<br>Change time:对文件Inode信息最后修改时间</p><p>ls：列出该目录下的所有子目录与文件</p><p>  -a:列出目录下的所有文件，包括以.开头的隐含文件</p><p>  -l:列出文件的详细信息</p><p>  -i输出文件的i节点的索引信息    inode编号</p><p>cd ：改变工作目录。将当前工作目录改变到指定的目录下</p><p>  -:返回最近访问目录</p><p>  ~:进入用户家目录</p><p>pwd：显示用户当前所在的目录</p><p>touch：创建普通文件,也可更改文档和时间</p><p>  -a:访问时间</p><p>  -c:创建时间</p><p>  -m:变动时间</p><p>mkdir:创建目录</p><p>   -p:即一次可以建立多个目录</p><p>tree：自动给以树形的形式列出当前目录的文件和文件夹，不加任何参数，它会自动列表当前目录下面所有深度级别的文件和目录</p><p>rmdir:删除空目录</p><p>  -p:当子目录被删除后如果父目录也变成空目录的话，就连带父目录一起删除。</p><p>rm:删除文件或目录</p><p>   -f:即使文件属性为只读（即写保护），也直接删除</p><p>   -r:删除目录</p><p>   -rf:强制删除</p><p>man:访问Linux手册页</p><p>cp:复制文件或目录</p><p>-f:强制复制文件或目录，不论目的文件或目录是否已经存在</p><p>-R:拷贝目录，将制定目录下的文件及子目录一并处理</p><p>echo:重定向         &gt; :输出重定向</p><p>mv:移动文件或重命名</p><p>将rm改造成mv：     alias 别名</p><p>cat/tac:查看目标文件的内容，把文件内容正序/倒序显示出来</p><p>-b:对非空输出行编号</p><p>-n:对输出的所有行编号</p><p>-s:不输出多行空行</p><p>more:默认把当前显示器填满     </p><p> -n:对输出的所有行编号</p><p>  q:退出more</p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 指令 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>缺省参数、函数重载、引用、C++11</title>
      <link href="/2019/04/09/%E7%BC%BA%E7%9C%81%E5%8F%82%E6%95%B0%E3%80%81%E5%87%BD%E6%95%B0%E9%87%8D%E8%BD%BD%E3%80%81%E5%BC%95%E7%94%A8%E3%80%81C-11/"/>
      <url>/2019/04/09/%E7%BC%BA%E7%9C%81%E5%8F%82%E6%95%B0%E3%80%81%E5%87%BD%E6%95%B0%E9%87%8D%E8%BD%BD%E3%80%81%E5%BC%95%E7%94%A8%E3%80%81C-11/</url>
      
        <content type="html"><![CDATA[<h4 id="命名空间："><a href="#命名空间：" class="headerlink" title="命名空间："></a>命名空间：</h4><pre><code>printf(&quot;%d\n&quot;,a);         //访问最近定义的aprintf(&quot;%d\n&quot;,::a);       //访问全局域的aprintf(&quot;%d\n&quot;,my::a);     //访问my这个命名空间的aprintf(&quot;%d\n&quot;,your::a);   //访问your这个命名空间的ausing namespace std;   //std  C++库的命名空间</code></pre><h4 id="缺省参数："><a href="#缺省参数：" class="headerlink" title="缺省参数："></a>缺省参数：</h4><pre><code>缺省参数是声明或定义函数时为函数的参数指定一个默认值。在调用该函数时，如果没有指定实参则采用该默认值，否则使用指定的实参。半缺省参数必须从右往左依次给出，不能间隔着给。缺省参数不能在函数声明和定义中同时出现，那么编译器就无法确定到底该用哪个缺省值。</code></pre><h4 id="函数重载："><a href="#函数重载：" class="headerlink" title="函数重载："></a>函数重载：</h4><pre><code>这些同名函数的形参列表（参数个数 或 参数类型 或 顺序）必须不同，和返回值类型无关。为什么C语言不支持函数重载，而C++支持函数重载？C语言的名字修饰规则非常简单，只是在函数名字前面添加了下划线。C++修饰规则，被重新修饰的名字中包含了：函数名字和参数类型，这样就保证了名字在底层的全局唯一性</code></pre><h4 id="引用："><a href="#引用：" class="headerlink" title="引用："></a>引用：</h4><pre><code>给变量取一个别名，不会为引用开辟新的内存空间，它和它引用的变量共用同一块内存空间。类型 &amp; 引用变量名=引用实体int &amp; ra =a;            引用类型必须和引用实体是同种类型。引用在定义时必须初始化。一个变量可以有多个引用。引用一旦引用一个实体，再不能引用其他实体。引用的使用场景：1.做参数2.做返回值   做返回值时，传引用能够不用再去开辟一块新的内存空间，如果返回一个结构体或者特别大的空间时，比较节约内存。   做返回值时，离开函数作用域后，其栈上空间已经返回到系统，因此不能用栈上的空间作为引用类型返回。如果以引用类型返回，返回值的生命周期必须不受函数的限制（即比函数生命周期长）。</code></pre><h5 id="常引用："><a href="#常引用：" class="headerlink" title="常引用："></a>常引用：</h5><pre><code>const int a=10;      int &amp;ra=a;     （错误）a为常量，不能被修改const int&amp; ra=a;     （正确）必须加const，a为常量。      int &amp;b=10；    （错误）const int &amp;b=10;     （正确）        int c = 20；const int &amp;d = c；    （正确）都不能被修改     int  e = 20;    double f = e;     (正确)发生了隐式类型的转化，是相近类型。e把数据给临时变量，临时变量                             把数据再给f，而临时变量具有常性   double&amp; f = e;     (错误）const double&amp; f = e; （正确）这里的f不是e的别名，而是那个临时变量的别名</code></pre><h5 id="引用和指针的区别（重点）："><a href="#引用和指针的区别（重点）：" class="headerlink" title="引用和指针的区别（重点）："></a>引用和指针的区别（重点）：</h5><pre><code>1.引用在定义时必须初始化，指针没有要求2.引用在初始化时引用一个实体后，就不能再引用其他实体，而指针可以在任何时候指向任何一个同类型实体。3.没有NULL引用，但有NULL指针。4.在sizeof中含义不同：引用结果为引用类型的大小，但指针始终是地址空间所占字节个数（32位平台下占4个字节）。5.引用自加即引用的实体增加1，指针自加即指针向后偏移一个类型的大小。6.有多级指针，但是没有多级引用。7.访问实体方式不同，指针需要显式解引用，引用编译器自己处理。8.引用比指针使用起来相对更安全。</code></pre><pre><code>在性能上，传指针和传引用的效率几乎相同。在语法层面上，引用就是个别名，没有独立空间。在底层实现上，引用实际是有空间的，因为引用是按照指针方式来实现的。</code></pre><h4 id="内联函数"><a href="#内联函数" class="headerlink" title="内联函数"></a>内联函数</h4><pre><code>以inline修饰的函数叫做内联函数，编译时C++编译器在调用内联函数的地方展开，没有函数压栈的开销，内联函数提升程序运行的效率。1.内联是一种以空间换时间的做法，省去调用函数额外开销。所以代码很长或者有循环/递归的函数不适宜使用作为内联函数。2.inline对编译器而言只是一个建议，编译器会自动优化，编译器也可以会忽略掉内联。3.inline不建议声明和定义分离，分离会导致链接错误。因为linline会展开，就没有函数地址了，链接就会找不到。</code></pre><h5 id="面试题：宏的优缺点"><a href="#面试题：宏的优缺点" class="headerlink" title="面试题：宏的优缺点"></a>面试题：宏的优缺点</h5><pre><code>宏：优点：1.增强代码的复用性     2.提高性能缺点：1.不方便调试     2.导致代码可维护性差、可读性差     3.没有类型安全的检查，不安全C++用const替换宏常量   用内联函数替换宏函数</code></pre><h4 id="auto关键字（C-11"><a href="#auto关键字（C-11" class="headerlink" title="auto关键字（C++11)"></a>auto关键字（C++11)</h4><pre><code>auto不再是一个存储类型指示符，而是作为一个新的类型指示符来指示编译器，auto声明的变量必须由编译器在编译时期推导而得。int a = 10;auto b = a;   //整型auto c = &#39;a&#39;; //字符型auto e；      //无法通过编译，使用auto定义变量时必须对其进行初始化auto并非是一种“类型”的声明，而是一个类型声明时的“占位符”，编译器在编译期会将auto替换为变量实际的类型。用auto声明指针类型时，用auto和auto*没有任何区别，但用auto声明引用类型时则必须加&amp;。当在同一行声明多个变量时，这些变量必须是相同的类型，否则编译器将会报错，因为编译器实际只对第一个类型进行推导，然后用推导出来的类型定义其他变量。auto不能推导的场景：1.auto不能作为函数的参数2.auto不能直接用来声明数组3.auto不能定义类的非静态成员变量4.实例化模板时不能使用auto作为模板参数5.为了避免与C++98中的auto发生混淆，C++11只保留了auto作为类型指示符的用法6.auto在实际中最常见的优势用法就是跟以后会讲到的C++11提供的新式for循环，还有lambda表达式等进行配合使用</code></pre><h4 id="基于范围的for循环（C-11）"><a href="#基于范围的for循环（C-11）" class="headerlink" title="基于范围的for循环（C++11）"></a>基于范围的for循环（C++11）</h4><pre><code>for循环后的括号由冒号“ ：”分为两部分：第一部分是范围内用于迭代的变量，第二部分则表示被迭代的范围。</code></pre><h4 id="指针空值nullptr-C-11"><a href="#指针空值nullptr-C-11" class="headerlink" title="指针空值nullptr(C++11)"></a>指针空值nullptr(C++11)</h4><pre><code>nullptr代表一个指针空值常量，nullptr是有类型的，其类型为nullptr_t，仅仅可以被隐式转化为指针类型typedef decltype(nullptr) nullptr_t;注意：1. 在使用nullptr表示指针空值时，不需要包含头文件，因为nullptr是C++11作为新关键字引入的。2. 在C++11中，sizeof(nullptr) 与 sizeof((void*)0)所占的字节数相同。3. 为了提高代码的健壮性，在后续表示指针空值时建议最好使用nullptr。</code></pre>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 概念 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CPU密集型、IO密集型</title>
      <link href="/2019/04/08/CPU%E5%AF%86%E9%9B%86%E5%9E%8B%E3%80%81IO%E5%AF%86%E9%9B%86%E5%9E%8B/"/>
      <url>/2019/04/08/CPU%E5%AF%86%E9%9B%86%E5%9E%8B%E3%80%81IO%E5%AF%86%E9%9B%86%E5%9E%8B/</url>
      
        <content type="html"><![CDATA[<h3 id="什么是CPU密集型、IO密集型？以及俩的区别？"><a href="#什么是CPU密集型、IO密集型？以及俩的区别？" class="headerlink" title="什么是CPU密集型、IO密集型？以及俩的区别？"></a>什么是CPU密集型、IO密集型？以及俩的区别？</h3><h4 id="IO密集型（I-O-bound）"><a href="#IO密集型（I-O-bound）" class="headerlink" title="IO密集型（I/O bound）"></a>IO密集型（I/O bound）</h4><p>IO密集型指的是系统的CPU性能相对硬盘、内存要好很多，此时的系统运作，大部分都是CPU在等I/O（硬盘/内存）的读写操作，对CPU的利用、占有率较差，没有充分的利用处理器能力。</p><h4 id="CPU密集型"><a href="#CPU密集型" class="headerlink" title="CPU密集型"></a>CPU密集型</h4><p>CPU密集型也叫计算密集型，指的是系统的硬盘、内存性能相对CPU要好很多，此时系统大部分时间都在用来计算、逻辑判断等CPU动作。CPU密集型的程序一般而言CPU占用率很高，可能是因为任务本身不太需要访问I/O设备，也可能是因为程序是多线程实现因此屏蔽掉了等待I/O的时间。</p><h4 id="CPU密集型-vs-IO密集型"><a href="#CPU密集型-vs-IO密集型" class="headerlink" title="CPU密集型 vs IO密集型"></a>CPU密集型 vs IO密集型</h4><p>可以把任务分为计算密集型和IO密集型。</p><p>计算密集型任务的特点是要进行大量的计算，消耗CPU资源，比如计算圆周率、对视频进行高清解码等等，全靠CPU的运算能力。这种计算密集型任务虽然也可以用多任务完成，但是任务越多，花在任务切换的时间就越多，CPU执行任务的效率就越低，所以，要最高效地利用CPU，计算密集型任务同时进行的数量应当等于CPU的核心数。</p><p>计算密集型任务由于主要消耗CPU资源，因此，代码运行效率至关重要。Python这样的脚本语言运行效率很低，完全不适合计算密集型任务。对于计算密集型任务，最好用C语言编写。</p><p>第二种任务的类型是IO密集型，涉及到网络、磁盘IO的任务都是IO密集型任务，这类任务的特点是CPU消耗很少，任务的大部分时间都在等待IO操作完成（因为IO的速度远远低于CPU和内存的速度）。对于IO密集型任务，任务越多，CPU效率越高，但也有一个限度。常见的大部分任务都是IO密集型任务，比如Web应用。</p><p>IO密集型任务执行期间，99%的时间都花在IO上，花在CPU上的时间很少，因此，用运行速度极快的C语言替换用Python这样运行速度极低的脚本语言，完全无法提升运行效率。对于IO密集型任务，最合适的语言就是开发效率最高（代码量最少）的语言，脚本语言是首选，C语言最差。</p><h5 id="总之，计算密集型程序适合C语言多线程，I-O密集型适合脚本语言开发的多线程。"><a href="#总之，计算密集型程序适合C语言多线程，I-O密集型适合脚本语言开发的多线程。" class="headerlink" title="总之，计算密集型程序适合C语言多线程，I/O密集型适合脚本语言开发的多线程。"></a>总之，计算密集型程序适合C语言多线程，I/O密集型适合脚本语言开发的多线程。</h5>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CPU </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
